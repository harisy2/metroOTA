/***********************
 * ESP32 + nanopb + GTFS-Realtime TripUpdates (protobuf, no gzip)
 * Streams entities & stop_time_update via callbacks (tiny RAM).
 ***********************/
#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <FS.h>
#include <SPIFFS.h>
#include <vector>
#include <climits>
#define DEST_FS_USES_SPIFFS
#include <ESP32-targz.h>
#include <FS.h>
#include <SPIFFS.h>
#include <map>
#include <time.h>
#include "secrets.h"
#include "config.h"
// ---- nanopb ----
extern "C"
{
#include "pb.h"
#include "pb_decode.h"
}
#include "gtfs-realtime.pb.h" // generated by protoc --nanopb_out
#include <Adafruit_NeoPixel.h>
#include <Adafruit_GFX.h>
// ======= CONFIG =======

Adafruit_NeoPixel strip(NUM_LEDS, PIN, NEO_GRB + NEO_KHZ800);
struct TrainInfo;

// IMPORTANT: rotate your real keys; don’t ship hardcoded secrets.
static const char *API_TRIPUPDATES = TRIP_UPDATES_URL;
static const char *API_STOPS = STOPS_URL;

uint16_t color565(uint8_t r, uint8_t g, uint8_t b)
{
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

static std::map<String, String> stopMap;
static std::map<String, uint16_t> colorMap = {
    {"B", color565(0, 0, 255)},
    {"R", color565(255, 0, 0)},
    {"G", color565(10, 160, 5)},
    {"Y", color565(200, 200, 25)},
    {"O", color565(250, 150, 5)}};

//------LED STUFF lol----------//

// Convert RGB565 to NeoPixel 24-bit color
uint32_t color565To24(uint16_t color)
{
    uint8_t r = ((color >> 11) & 0x1F) << 3;
    uint8_t g = ((color >> 5) & 0x3F) << 2;
    uint8_t b = (color & 0x1F) << 3;
    return strip.Color(r, g, b);
}

class LEDCanvas : public Adafruit_GFX
{
public:
    LEDCanvas(uint16_t w, uint16_t h) : Adafruit_GFX(w, h) {}

    void drawPixel(int16_t x, int16_t y, uint16_t color) override
    {
        if (x < 0 || x >= MATRIX_WIDTH || y < 0 || y >= MATRIX_HEIGHT)
            return;
        strip.setPixelColor(getIndexFromXY(x, y), color565To24(color));
    }

    static uint16_t getIndexFromXY(uint8_t x, uint8_t y)
    {
        // Determine which panel this x,y belongs to
        uint8_t panelX = x / PANEL_W;
        uint8_t panelY = y / PANEL_H;

        // Physical panel index (left to right = panel 3 → panel 0)
        uint8_t physicalPanel = (NUM_PANELS - 1) - panelX;

        // Coordinates within that panel
        uint8_t localX = x % PANEL_W;
        uint8_t localY = y % PANEL_H;

        // Serpentine layout handling inside the panel
        uint16_t indexInPanel;
        // Flipped serpentine layout
        if (localY % 2 == 0)
        {
            // Even row: right → left
            indexInPanel = localY * PANEL_W + (PANEL_W - 1 - localX);
        }
        else
        {
            // Odd row: left → right
            indexInPanel = localY * PANEL_W + localX;
        }

        // Final index in strip
        uint16_t panelIndexInStrip = panelY * NUM_PANELS + physicalPanel;
        return panelIndexInStrip * (PANEL_W * PANEL_H) + indexInPanel;
    }
};

LEDCanvas canvas(MATRIX_WIDTH, MATRIX_HEIGHT);

static inline String stopName(const String &id)
{
    if (!id.length())
        return String("");
    auto it = stopMap.find(id);
    return (it != stopMap.end()) ? it->second : id; // fallback: show the id
}

// ======= Types =======
struct TrainInfo
{
    String line, curr, next;
    int64_t arrivalTime = 0;
};

#include <freertos/FreeRTOS.h>
#include <freertos/semphr.h>
static SemaphoreHandle_t g_fsMutex = nullptr;
static SemaphoreHandle_t linesMutex = nullptr;
struct FsLock
{
    SemaphoreHandle_t m;
    explicit FsLock(SemaphoreHandle_t mm) : m(mm)
    {
        if (m)
            xSemaphoreTake(m, portMAX_DELAY);
    }
    ~FsLock()
    {
        if (m)
            xSemaphoreGive(m);
    }
    FsLock(const FsLock &) = delete;
    FsLock &operator=(const FsLock &) = delete;
};

// ======= Wi-Fi =======
static bool ensureWifi(uint32_t timeout_ms = 15000)
{
    if (WiFi.status() == WL_CONNECTED)
        return true;
    WiFi.mode(WIFI_STA);
    WiFi.setSleep(false);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    uint32_t start = millis();
    while (millis() - start < timeout_ms)
    {
        if (WiFi.status() == WL_CONNECTED)
            return true;
        delay(250);
    }
    return false;
}

// ======= nanopb File istream =======
static bool file_read_cb(pb_istream_t *stream, pb_byte_t *buf, size_t count)
{
    File *fp = (File *)stream->state;
    size_t n = fp->read(buf, count);
    return (n == count);
}
static pb_istream_t istream_from_file(File &f)
{
    pb_istream_t s;
    s.callback = &file_read_cb;
    s.state = &f;
    s.bytes_left = f.size();
    return s;
}

// ======= Decode callbacks =======
struct FeedCtx
{
    transit_realtime_FeedMessage *feed;
    std::vector<TrainInfo> *out;
};

struct TripCtx
{
    const FeedCtx *top = nullptr;
    // rolling state while iterating StopTimeUpdate
    String lastBefore;       // last stop with time < feed_time
    String curr;             // chosen "current" stop
    String next;             // chosen "next" stop
    int64_t arrivalTime = 0; // arrival time for "next"
    // detection of "at-stop" (TIME between arrival..departure)
    bool currSet = false;           // we found curr because TIME within [arr,dep]
    bool needNextAfterCurr = false; // next StopTimeUpdate becomes "next"
    // best future candidate if not at-stop
    String futureNext;
    int64_t bestFutureArr = 0;
};

static inline int64_t eff_arr(const transit_realtime_TripUpdate_StopTimeUpdate &stu)
{
    return (int64_t)(stu.arrival.time ? stu.arrival.time : stu.departure.time);
}
static inline int64_t eff_dep(const transit_realtime_TripUpdate_StopTimeUpdate &stu)
{
    // prefer departure if present, else arrival
    return (int64_t)(stu.departure.time ? stu.departure.time : stu.arrival.time);
}

// Stream each TripUpdate.StopTimeUpdate (nested type!)
static bool stop_time_update_cb(pb_istream_t *stream, const pb_field_t *, void **arg)
{
    TripCtx *ctx = (TripCtx *)(*arg);

    transit_realtime_TripUpdate_StopTimeUpdate stu =
        transit_realtime_TripUpdate_StopTimeUpdate_init_zero;

    if (!pb_decode(stream, transit_realtime_TripUpdate_StopTimeUpdate_fields, &stu))
        return false;

    const int64_t feed_time = (ctx->top && ctx->top->feed) ? (int64_t)ctx->top->feed->header.timestamp : 0;
    const int64_t arr = eff_arr(stu); // 0 if no times present
    const int64_t dep = eff_dep(stu); // 0 if no times present
    const String sid = (stu.stop_id && stu.stop_id[0]) ? String(stu.stop_id) : String("");

    // If we already found we're "at" a stop, the very next update is our next stop.
    if (ctx->needNextAfterCurr && !ctx->next.length())
    {
        ctx->next = sid;
        ctx->arrivalTime = arr;
        ctx->needNextAfterCurr = false; // done
                                        // continue scanning in case we need more info, but we've got what we need
    }

    // Detect "currently at stop": TIME within [arr..dep] when either is available
    if (!ctx->currSet && arr > 0)
    {
        int64_t from = arr;
        int64_t to = dep ? dep : arr; // if no dep, collapse to arrival instant
        if (feed_time >= from && feed_time <= to)
        {
            ctx->curr = sid;
            ctx->currSet = true;
            ctx->needNextAfterCurr = true; // the following StopTimeUpdate becomes "next"
        }
    }

    // Track last stop strictly before TIME (for the non-'at stop' path)
    if (arr > 0 && arr < feed_time)
    {
        ctx->lastBefore = sid;
    }

    // Track best future candidate (earliest arrival >= TIME)
    if (arr > 0 && arr >= feed_time)
    {
        if (ctx->bestFutureArr == 0 || arr < ctx->bestFutureArr)
        {
            ctx->bestFutureArr = arr;
            ctx->futureNext = sid;
        }
    }

    return true;
}

// Stream each FeedEntity; compute TrainInfo for TripUpdate
static bool entity_decode_cb(pb_istream_t *stream, const pb_field_t *, void **arg)
{
    FeedCtx *feed = (FeedCtx *)(*arg);

    transit_realtime_FeedEntity ent = transit_realtime_FeedEntity_init_zero;

    // Attach nested callback before decoding entity
    TripCtx tctx;
    tctx.top = feed;
    ent.trip_update.stop_time_update.funcs.decode = &stop_time_update_cb;
    ent.trip_update.stop_time_update.arg = &tctx;

    if (!pb_decode(stream, transit_realtime_FeedEntity_fields, &ent))
        return false;

    // route_id is a fixed-size char[] if you used max_size in .options
    String route_id;
    if (ent.trip_update.trip.route_id && ent.trip_update.trip.route_id[0])
        route_id = String(ent.trip_update.trip.route_id);

    // Build TrainInfo with robust curr/next selection
    TrainInfo t;
    t.line = route_id;

    if (tctx.currSet)
    {
        // We were at a stop; prefer the real "next" that followed it
        t.curr = stopName(tctx.curr);
        if (tctx.next.length())
        {
            t.next = stopName(tctx.next);
            t.arrivalTime = tctx.arrivalTime;
        }
        else
        {
            t.next = "END";
            t.arrivalTime = 0;
        }
    }
    else if (tctx.futureNext.length())
    {
        // We were between stops before the first future arrival
        t.curr = stopName(tctx.lastBefore); // may be empty if we're before the very first stop
        t.next = stopName(tctx.futureNext);
        t.arrivalTime = tctx.bestFutureArr;
    }
    else
    {
        // No future stops left → at/after the last listed stop
        t.curr = stopName(tctx.lastBefore); // last known stop
        t.next = "END";
        t.arrivalTime = 0;
    }

    // Optional: avoid blank curr in UI
    if (!t.curr.length())
        t.curr = String("NOSTN");

    // Only push meaningful TripUpdates
    if (t.line.length() || t.next.length() || t.curr.length())
        feed->out->push_back(std::move(t));

    return true;
}

// ======= Main function: fetch + decode (no gzip) =======
std::vector<TrainInfo> fetchAndDecodeTripUpdatesPBF(const char *url,
                                                    const char *localPath = "/transit.pbf")
{
    std::vector<TrainInfo> out;
    out.reserve(128);

    if (!ensureWifi())
    {
        Serial.println("WiFi not connected");
        return out;
    }

    // ---- 1) Download protobuf (no gzip) ----
    HTTPClient http;
    http.setTimeout(20000);
    http.setFollowRedirects(HTTPC_STRICT_FOLLOW_REDIRECTS);
    http.addHeader("Accept", "application/x-google-protobuf"); // ask for protobuf only
    // DO NOT add Accept-Encoding:gzip

    if (!http.begin(url))
    {
        Serial.println("HTTP begin failed");
        return out;
    }

    int code = http.GET();
    if (code != HTTP_CODE_OK)
    {
        Serial.printf("HTTP error %d\n", code);
        http.end();
        return out;
    }

    // If server still gzips, bail (you said no gzip for .pbf)
    String enc = http.header("Content-Encoding");
    if (enc.equalsIgnoreCase("gzip"))
    {
        Serial.println("Server sent gzip for .pbf; this path expects plain protobuf.");
        http.end();
        return out;
    }

    {
        FsLock lk(g_fsMutex);
        SPIFFS.remove(localPath);
        File f = SPIFFS.open(localPath, FILE_WRITE);
        if (!f)
        {
            http.end();
            Serial.println("open(dest) failed");
            return out;
        }
        size_t w = http.writeToStream(&f);
        f.close();
        if (w == 0)
        {
            http.end();
            Serial.println("no bytes written");
            return out;
        }
    }
    http.end();

    // ---- 2) Stream-decode protobuf with nanopb ----
    File f;
    {
        FsLock lk(g_fsMutex);
        f = SPIFFS.open(localPath, FILE_READ);
    }
    if (!f)
    {
        Serial.println("open(pbf) failed");
        return out;
    }

    pb_istream_t s = istream_from_file(f);

    transit_realtime_FeedMessage feed = transit_realtime_FeedMessage_init_zero;

    // Attach entity-level streaming callback
    FeedCtx ctx;
    ctx.feed = &feed;
    ctx.out = &out;
    feed.entity.funcs.decode = &entity_decode_cb;
    feed.entity.arg = &ctx;

    bool ok = pb_decode(&s, transit_realtime_FeedMessage_fields, &feed);
    if (!ok)
    {
        Serial.printf("pb_decode error: %s\n", PB_GET_ERROR(&s));
        f.close();
        return out;
    }
    f.close();

    // Optional: delete file after processing
    {
        FsLock lk(g_fsMutex);
        SPIFFS.remove(localPath);
    }

    return out;
}

// Convert Unix epoch (seconds or milliseconds) to local time "HH:MM AM/PM"
String formatLocalHHMM(int64_t epoch)
{
    if (epoch <= 0)
        return String("--:--");

    // If the value looks like milliseconds (e.g., 1_755_000_000_000), convert to seconds.
    if (epoch > 100000000000LL)
        epoch /= 1000;

    time_t t = (time_t)epoch; // time_t is seconds since 1970
    struct tm tmLocal;
    if (!localtime_r(&t, &tmLocal))
        return String("--:--"); // thread-safe variant

    char buf[16];
    // %I = 12-hour, leading zero; %M = minutes; %p = AM/PM
    // Example: "05:32 PM"
    if (strftime(buf, sizeof(buf), "%I:%M %p", &tmLocal) == 0)
    {
        return String("--:--");
    }
    return String(buf);
}

void initClock()
{
    // Sync system clock from NTP (UTC)
    configTime(0, 0, "pool.ntp.org", "time.nist.gov"); // offsets 0 because we’ll use TZ below

    // Set local timezone (US Pacific: PST/PDT with DST rules)
    setenv("TZ", "PST8PDT,M3.2.0,M11.1.0", 1); // posix TZ string
    tzset();                                   // apply
}

static bool sanitizeJsonFile(const char *inPath)
{
    // Copy from inPath -> temp, starting at first '{' or '['
    File in = SPIFFS.open(inPath, FILE_READ);
    if (!in)
    {
        Serial.println("sanitize: open failed");
        return false;
    }

    // Find JSON start
    size_t start = 0;
    bool found = false;
    while (in.available())
    {
        int c = in.read();
        if (c == '{' || c == '[')
        {
            start = in.position() - 1;
            found = true;
            break;
        }
    }
    if (!found)
    {
        in.close();
        Serial.println("sanitize: no JSON start found");
        return false;
    }
    in.seek(start);

    // Copy remainder to a clean temp
    const char *tmp = "/_tmp_clean.json";
    File out = SPIFFS.open(tmp, FILE_WRITE);
    if (!out)
    {
        in.close();
        Serial.println("sanitize: tmp open failed");
        return false;
    }

    uint8_t buf[2048];
    while (in.available())
    {
        int n = in.read(buf, sizeof(buf));
        if (n > 0)
            out.write(buf, n);
    }
    out.close();
    in.close();

    // Replace the original with clean file
    SPIFFS.remove(inPath);
    bool ok = SPIFFS.rename(tmp, inPath);
    Serial.printf("sanitize: %s -> %s\n", inPath, ok ? "ok" : "FAIL");
    if (!ok)
        SPIFFS.remove(tmp);
    return ok;
}
static void buildStopMapFromSPIFFS()
{
    if (!ensureWifi())
    {
        Serial.println("WiFi not connected");
        return;
    }
    HTTPClient http;
    http.begin(API_STOPS);
    int code = http.GET();
    if (code != HTTP_CODE_OK)
    {
        Serial.printf("HTTP ERROR: %d\n", code);
        http.end();
        return;
    }
    Stream *stream = http.getStreamPtr();
    GzUnpacker *gz = new GzUnpacker();
    gz->haltOnError(true);
    gz->setupFSCallbacks(targzTotalBytesFn, targzFreeBytesFn);
    gz->setGzMessageCallback(BaseUnpacker::targzPrintLoggerCallback);

    bool ok = gz->gzStreamExpander(stream, tarGzFS, "/stops.json");
    if (!ok)
    {
        Serial.printf("Decompression failed, err %d\n", gz->tarGzGetError());
    }
    else
    {
        Serial.println("Decompression succeeded");
    }

    delete gz;
    http.end();

    sanitizeJsonFile("/stops.json");
    File file = SPIFFS.open("/stops.json", "r");
    DynamicJsonDocument doc(40 * 1024);
    DeserializationError err = deserializeJson(doc, file);
    file.close();
    doc.shrinkToFit();
    for (JsonObject entity : doc["Contents"]["dataObjects"]["ScheduledStopPoint"].as<JsonArray>())
    {
        String id = entity["id"].as<String>();
        String stopName = entity["Name"].as<String>();
        stopMap[id] = stopName;
    }
    SPIFFS.remove("/stops.json");
}

static std::vector<TrainInfo> filter(std::vector<TrainInfo> a)
{
    std::vector<TrainInfo> woot;
    for (TrainInfo train : a)
    {
        if (train.curr != "NOSTN" && train.next != "END")
        {
            woot.push_back(train);
        }
    }
    return woot;
}
// static String reformatLine(String s){
//   int idx = s.indexOf("-");
//   return "" + s.substring(0,idx) + " (" + dirMap[s.substring(idx+1)] + ")";
// }
// static std::vector<String> createLines(std::vector<TrainInfo> trains){
//   std::vector<String> out;
//   for (TrainInfo train : trains){
//     if(train.curr != "NOSTN" && train.next != "END"){
//       String final = "" + reformatLine(train.line) + " -> " + train.next + " From: " + train.curr + " | ETA: " + formatLocalHHMM(train.arrivalTime);
//       out.emplace_back(final);
//     }
//   }
//   return out;
// }
static void displayTask(TrainInfo *first, TrainInfo *second)
{
    // always same line: first may be defined but second is not always defined
    String dir2, station2;
    int16_t x1, y1;
    uint16_t w, h;
    int textX1 = 64;
    int timer = 0;
    int limit1 = 0;
    int limit2 = 0;
    uint16_t blnk = color565(0, 0, 0);
    uint16_t txcol = color565(245, 185, 20);
    bool secondE = false;
    String line = first->line.substring(0, 1);
    uint16_t bg = colorMap[line];
    String dir1 = first->line.substring(first->line.indexOf("-") + 1) + ":";
    String station1 = first->next + " " + formatLocalHHMM(first->arrivalTime);
    canvas.getTextBounds(station1.c_str(), 0, 0, &x1, &y1, &w, &h);
    limit1 = 28 - w;
    if (second != nullptr)
    {
        secondE = true;
        dir2 = second->line.substring(second->line.indexOf("-") + 1) + ":";
        station2 = second->next + " " + formatLocalHHMM(second->arrivalTime);
        canvas.getTextBounds(station2.c_str(), 0, 0, &x1, &y1, &w, &h);
        limit2 = 28 - w;
    }
    if (limit2 < limit1)
    {
        limit1 = limit2;
    }
    for (;;)
    {
        strip.clear();
        canvas.setTextSize(1);
        canvas.setTextColor(txcol, blnk);
        canvas.setCursor(textX1, 1);
        canvas.print(station1.c_str());
        if (secondE)
        {
            canvas.setCursor(textX1, 9);
            canvas.print(station2.c_str());
        }
        canvas.fillRect(0, 0, 29, 16, blnk);
        canvas.fillRect(0, 0, 16, 16, bg);
        canvas.setCursor(3, 1);
        canvas.setTextSize(2);
        canvas.setTextColor(color565(100, 100, 100), bg);
        canvas.print(line.c_str());
        canvas.setTextSize(1);
        canvas.setTextColor(color565(100, 100, 100), blnk);
        canvas.setCursor(17, 1);
        canvas.print(dir1.c_str());
        if (secondE)
        {
            canvas.setCursor(17, 9);
            canvas.print(dir2.c_str());
        }
        strip.show();
        if (--textX1 < limit1 && timer > 13000)
        {
            textX1 = 64;
            break;
        }
        else if (--textX1 < limit1)
        {
            textX1 = 64;
        }
        else
        {
            textX1--;
        }
        delay(200);
        timer = timer + 200;
    }
}

std::vector<TrainInfo> t;

// ======= Demo =======
void setup()
{
    strip.begin();
    strip.setBrightness(2);
    canvas.setTextWrap(false);
    g_fsMutex = xSemaphoreCreateMutex();
    linesMutex = xSemaphoreCreateMutex();
    Serial.begin(115200);
    delay(300);
    stopMap["END"] = "END";
    initClock();
    if (!SPIFFS.begin(true))
    {
        Serial.println("SPIFFS mount failed");
        while (1)
            delay(1000);
    }
    tarGzFS.begin(true);
    buildStopMapFromSPIFFS();
    t = filter(fetchAndDecodeTripUpdatesPBF(API_TRIPUPDATES));
}

void loop()
{
    displayTask(&t[0], &t[1]);
}
